Cube
====================================

	shuffleByExplosion(source?: object): Cube {

		const permutations = [new Array<number>(), new Array<number>(), new Array<number>()];
		const orientations = [new Array<number>(), new Array<number>(), new Array<number>()];

		for (const type of CubePartType.getAll()) {

			const n = type.countLocations(this.spec);
			//RandomPermutation of 1...n
			//Make a pool of all indices, choose a random one, then delete it from the pool etc
			const indexPool = Array<number>();
			for (let index = 0; index < n; index++) { indexPool.push(index); }
			for (let initialindex = 0; initialindex < n; initialindex++) { //Until indexPool is empty
				let indexindex = Random.randomIntegerFromToInclusivly(0, indexPool.length - 1);
				permutations[type.dimensionsCount][initialindex] = indexPool[indexindex];
				indexPool.splice(indexindex, 1);
				//Also random orientation
				orientations[type.dimensionsCount][initialindex] = Random.randomIntegerFromToInclusivly(0, type.countNormalVectors() - 1);
			}

		}

		this.setState(new CubeState(this.spec, permutations, orientations));

		return this;

	}



	getOrbit(): String {
		if (this.spec.edgeLength != 3 || this.spec.colored != true) throw new Error('Orbit problem only solved and implemented for SPEC (3, ColoredFaces)');
		let state: CubeState = this.getState();
		//Careful, since the cube can be rotated in space, the face permutations also have to be encountered
		let CornerPermutationsVsEdgePermutationsSignum = Cube.getSignum(state.permutations[0]) * Cube.getSignum(state.permutations[1]) * Cube.getSignum(state.permutations[2]);

		let CornerReorientationsSum = 0;
		for (let index = 0; index < CubePartType.CORNER.countLocations(this.spec); index++) {
			CornerReorientationsSum += state.reorientations[0][index];
		}
		let EdgeReorientationsSum = 0;
		for (let index = 0; index < CubePartType.EDGE.countLocations(this.spec); index++) {
			EdgeReorientationsSum += state.reorientations[1][index];
		}
		return "Orbit: Signums=" + CornerPermutationsVsEdgePermutationsSignum.toString()
			+ ", CornerOrientations=" + (CornerReorientationsSum % 3).toString()
			+ ", EdgeOrientations=" + (EdgeReorientationsSum % 2).toString();

	}

	/** Computes the signum of a permutation, used in getOrbit
	 * 
	 */
	private static getSignum(permutation: ReadonlyArray<number>): number {
		let signumCount = 0;
		for (let i: number = 0; i < permutation.length; i++) {
			for (let j: number = i + 1; j < permutation.length; j++) {
				if (permutation[i] > permutation[j]) signumCount++;
			}
		}
		//console.log(permutation);
		//console.log("SignumCount:"+signumCount);
		return Math.pow(-1, signumCount);
	}








	CUBICAL:
	
	beam(location: CubicalLocation, orientation: CubicalOrientation) {
		this.#location = location;
		if (!deepEqual(this.cube.spec, this.#location.spec)) throw new Error(`Invalid spec of location (expected: ${this.cube.spec}): ${this.#location.spec}`);
		if (!deepEqual(this.initialLocation.type, this.#location.type)) throw new Error(`Invalid type of location (expected: ${this.initialLocation.type}): ${this.#location.type}`);
		this.#orientation = orientation;
	}

	

	/** Computes, which initial face (color) is shown if one looks at the cube at the new location on some face.
	 * 
	 * @param cubeFace The face from which we look at the cubical
	 */
	//TODO: Was macht das hier?
	getColorShownOnSomeFace(cubeFace: CubeFace): CubeFace {
		this.location.part.isContainedInFace(cubeFace); // just validates the request
		let result: CubeFace = CubeFace.getByNormalVector(cubeFace.getNormalVector().transformAroundZero(inv(this.orientation.matrix)));
		this.initialLocation.part.isContainedInFace(result); // just validates the result
		return result;
	}